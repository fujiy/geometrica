
# ベクトル・座標系管理ライブラリ

# 基本的な考え方

## ベクトルは座標系によらない

ベクトルを表すときには，`(x, y, z)`のような成分表示がよく用いられる．しかし，厳密にはこのような成分表示自体はベクトルではなく，なんらかの基底`(e_x, e_y, e_z)`を用いて`x e_x + y e_y + z e_z`と表したものがベクトルである．
座標変換とは，ある基底`(e_x, e_y, e_z)`を用いて表した成分`(x, y, z)`を，別の基底`(e_X ,e_Y, e_Z)`で表した場合の成分`(X, Y, Z)`を求めることである（原点の移動を含む場合もある）．

よって，ベクトルを扱う際には，その成分表示だけでなくその基底（座標系）を同時に考える必要がある．これをプログラム上で記述する際，異なる座標系で表した成分同士をそのまま演算してしまうミスを防ぐには，成分ベクトルに座標系のタグを持たせる方法が思いつく．多相型を有する言語であれば，ベクトル型に幽霊型として座標系のタグを含めることで，型検査により異なる座標系同士の演算を許さない実装が可能だ．回転についても，座標系間の変換として変換前と変換後のタグを持たせれば，クォータニオンを掛ける順番や向きを間違えることがない．

しかしこの方法も完璧とはいえない．例えば，ある座標系の値（基底や原点）が時間変化する場合，この座標系の過去の値と現在の値に同じタグをつけるとするとこれらを区別できない．依存型を取り扱える言語であれば座標系の値自体を型に埋め込むこともできるが，そのような言語は（まだ？）あまり一般的ではない．

したがってこのライブラリでは，ベクトル型の変数やそれら同士の演算を常に座標系によらない形式で表すこととする．物理量や物理量同士の演算（内積や外積，テンソルとベクトルの積など）は基本的に座標系によらないため，力学の表現のためにベクトルを使う場面ではこのようにして困ることは少ないと思われる．これにより，座標変換のミスを（ベクトル型を扱っている限りにおいては）防ぐことができる．これはユーザーによる明示的な座標変換操作を省けることをも意味する．ユーザーは座標成分を指定してベクトルを生成するときと，ベクトルから座標成分を取り出すとき（プログラム外とやり取りするような必要最小限の場合に限る），および時間微分を扱うとき（後述）のみ座標系を明示的に指定する．

## 位置と位置の差，方向（速度）はそれぞれ区別する

ユークリッド空間においては，位置ベクトル，位置ベクトル同士の差，方向ベクトルや速度ベクトルは，いずれもベクトル空間の元であり，コード上でも型で区別しないことが多い．しかし，座標変換を行う上ではこれらは明確に区別する必要がある．アフィン空間の元である位置の座標変換は基底変換と原点の移動を伴うが，ベクトル空間の元である位置同士の差や方向に対する座標変換は基底変換のみだからである．よってこのライブラリではこれらは別々の型とする．（一般の多様体では，位置は多様体上の点，位置同士の差は測地線あるいは逆指数写像，方向や速度は接ベクトルとして明確に区別される．）

また，速度ベクトルのような時間微分によって生成されるベクトルを生成する際は，どの座標系から見た微分かを明示的に指定する．これは座標成分の変換とは異なり，座標系自体の時間変化を考慮した変換である．

# 実装

ベクトル自体は座標系によらないものとし，成分にアクセスする際は座標系を明示することを義務付ける．このようなインターフェースを用意するとして，ベクトルの内部表現としては以下のような実装方法が考えられる．

1. ただ一つの特別な基準座標系からみた成分を持つ．
2. 生成に用いた座標系（への参照）と，その座標系で表した成分表示の組を持つ．座標変換は演算時や成分取得時，必要になった時点で自動で行う．

1の方法は単純明快であるが，成分表示からベクトルを生成する度に必ず発生する座標変換のオーバーヘッドや，原点が大きく離れた座標系を扱う際の桁落ちによる精度低下といった懸念がある．一方で2の方法は内部での座標変換回数が最低限で済むが，座標変換ツリーを保持し変換経路を動的に探索およびキャッシュするといったように実装が複雑になる欠点がある．

本実装で検証したいのはあくまでインターフェースであるので，当面の実装は1の方法を採用する．
